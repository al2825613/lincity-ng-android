<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libxml++: xmlpp::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libxml++
   &#160;<span id="projectnumber">5.0.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacexmlpp.html">xmlpp</a></li><li class="navelem"><a class="el" href="classxmlpp_1_1Node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classxmlpp_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xmlpp::Node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents XML Nodes.  
 <a href="classxmlpp_1_1Node.html#details">More...</a></p>

<p><code>#include &lt;libxml++/nodes/node.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for xmlpp::Node:</div>
<div class="dyncontent">
<div class="center"><img src="classxmlpp_1_1Node__inherit__graph.png" border="0" usemap="#axmlpp_1_1Node_inherit__map" alt="Inheritance graph"/></div>
<map name="axmlpp_1_1Node_inherit__map" id="axmlpp_1_1Node_inherit__map">
<area shape="rect" title="Represents XML Nodes." alt="" coords="212,259,317,285"/>
<area shape="rect" href="classxmlpp_1_1Attribute.html" title="Represents an XML attribute node or attribute declaration." alt="" coords="389,56,517,83"/>
<area shape="rect" href="classxmlpp_1_1ContentNode.html" title="Content node." alt="" coords="375,183,531,209"/>
<area shape="rect" href="classxmlpp_1_1Element.html" title="Element nodes have attributes as well as child nodes." alt="" coords="390,233,515,260"/>
<area shape="rect" href="classxmlpp_1_1EntityReference.html" title="Entity references refer to previously declared entities." alt="" coords="365,284,540,311"/>
<area shape="rect" href="classxmlpp_1_1XIncludeEnd.html" title="XIncludeEnd node." alt="" coords="377,335,528,361"/>
<area shape="rect" href="classxmlpp_1_1XIncludeStart.html" title="XIncludeStart node." alt="" coords="373,385,532,412"/>
<area shape="rect" href="classxmlpp_1_1NonCopyable.html" title="A base for classes which cannot be copied or moved." alt="" coords="5,259,164,285"/>
<area shape="rect" href="classxmlpp_1_1AttributeDeclaration.html" title="Represents the default value of an attribute of an XML element node." alt="" coords="609,5,811,32"/>
<area shape="rect" href="classxmlpp_1_1AttributeNode.html" title="Represents an explicit attribute of an XML element node." alt="" coords="629,56,791,83"/>
<area shape="rect" href="classxmlpp_1_1CdataNode.html" title="CData node." alt="" coords="639,107,781,133"/>
<area shape="rect" href="classxmlpp_1_1CommentNode.html" title="Comment node." alt="" coords="625,157,795,184"/>
<area shape="rect" href="classxmlpp_1_1EntityDeclaration.html" title="Entity declaration." alt="" coords="618,208,802,235"/>
<area shape="rect" href="classxmlpp_1_1ProcessingInstructionNode.html" title=" " alt="" coords="588,259,832,285"/>
<area shape="rect" href="classxmlpp_1_1TextNode.html" title="Text node." alt="" coords="644,309,776,336"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a97f19f7f19c763f616eadb702680826f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a97f19f7f19c763f616eadb702680826f">const_NodeList</a> = <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08383.html">std::list</a>&lt; const <a class="el" href="classxmlpp_1_1Node.html">Node</a> * &gt;</td></tr>
<tr class="separator:a97f19f7f19c763f616eadb702680826f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dba85e747dbe53ff768955bc3ca46b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a> = <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08551.html">std::vector</a>&lt; const <a class="el" href="classxmlpp_1_1Node.html">Node</a> * &gt;</td></tr>
<tr class="separator:a57dba85e747dbe53ff768955bc3ca46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec484e80254d11ae0f7046e011287a18"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aec484e80254d11ae0f7046e011287a18">NodeList</a> = <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08383.html">std::list</a>&lt; <a class="el" href="classxmlpp_1_1Node.html">Node</a> * &gt;</td></tr>
<tr class="separator:aec484e80254d11ae0f7046e011287a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbb1903a13e213fa94898a76518ebc6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a> = <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08551.html">std::vector</a>&lt; <a class="el" href="classxmlpp_1_1Node.html">Node</a> * &gt;</td></tr>
<tr class="separator:aabbb1903a13e213fa94898a76518ebc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17584286cf6aea618a6d0878add65450"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> = <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08395.html">std::map</a>&lt; <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>, <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &gt;</td></tr>
<tr class="memdesc:a17584286cf6aea618a6d0878add65450"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of namespace prefixes to namespace URIs.  <a href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">More...</a><br /></td></tr>
<tr class="separator:a17584286cf6aea618a6d0878add65450"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a215d8c01b6b01596c4ea853f99dce8e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a215d8c01b6b01596c4ea853f99dce8e7">Node</a> (_xmlNode * node)</td></tr>
<tr class="separator:a215d8c01b6b01596c4ea853f99dce8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8dc1eea15e3e1ac42b43a49c3016ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aed8dc1eea15e3e1ac42b43a49c3016ba">~Node</a> () override</td></tr>
<tr class="memdesc:aed8dc1eea15e3e1ac42b43a49c3016ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classxmlpp_1_1Node.html#aed8dc1eea15e3e1ac42b43a49c3016ba">More...</a><br /></td></tr>
<tr class="separator:aed8dc1eea15e3e1ac42b43a49c3016ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d61ce066ad6ec4fca1e5637f7ec59a6"><td class="memItemLeft" align="right" valign="top">const _xmlNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a8d61ce066ad6ec4fca1e5637f7ec59a6">cobj</a> () const noexcept</td></tr>
<tr class="memdesc:a8d61ce066ad6ec4fca1e5637f7ec59a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the underlying libxml implementation.  <a href="classxmlpp_1_1Node.html#a8d61ce066ad6ec4fca1e5637f7ec59a6">More...</a><br /></td></tr>
<tr class="separator:a8d61ce066ad6ec4fca1e5637f7ec59a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648a236bfd53dcf4405446c8569d71b5"><td class="memItemLeft" align="right" valign="top">_xmlNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a648a236bfd53dcf4405446c8569d71b5">cobj</a> () noexcept</td></tr>
<tr class="memdesc:a648a236bfd53dcf4405446c8569d71b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the underlying libxml implementation.  <a href="classxmlpp_1_1Node.html#a648a236bfd53dcf4405446c8569d71b5">More...</a><br /></td></tr>
<tr class="separator:a648a236bfd53dcf4405446c8569d71b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259a1012c1a8cfb9c95ee51a7c3f9026"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a259a1012c1a8cfb9c95ee51a7c3f9026">eval_to_boolean</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp; namespaces, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> * result_type=nullptr) const</td></tr>
<tr class="memdesc:a259a1012c1a8cfb9c95ee51a7c3f9026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#a259a1012c1a8cfb9c95ee51a7c3f9026">More...</a><br /></td></tr>
<tr class="separator:a259a1012c1a8cfb9c95ee51a7c3f9026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0762a2fda0ede4be6f6a4a23c2eb2ae2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a0762a2fda0ede4be6f6a4a23c2eb2ae2">eval_to_boolean</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> * result_type=nullptr) const</td></tr>
<tr class="memdesc:a0762a2fda0ede4be6f6a4a23c2eb2ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#a0762a2fda0ede4be6f6a4a23c2eb2ae2">More...</a><br /></td></tr>
<tr class="separator:a0762a2fda0ede4be6f6a4a23c2eb2ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6d8da74d2014427a929fbc0464a4b8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#add6d8da74d2014427a929fbc0464a4b8">eval_to_number</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp; namespaces, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> * result_type=nullptr) const</td></tr>
<tr class="memdesc:add6d8da74d2014427a929fbc0464a4b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#add6d8da74d2014427a929fbc0464a4b8">More...</a><br /></td></tr>
<tr class="separator:add6d8da74d2014427a929fbc0464a4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1485086156a31d55f9079031429c94a7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a1485086156a31d55f9079031429c94a7">eval_to_number</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> * result_type=nullptr) const</td></tr>
<tr class="memdesc:a1485086156a31d55f9079031429c94a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#a1485086156a31d55f9079031429c94a7">More...</a><br /></td></tr>
<tr class="separator:a1485086156a31d55f9079031429c94a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3b5cb1dd19d79862b90ddc969946a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aac3b5cb1dd19d79862b90ddc969946a6">eval_to_string</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp; namespaces, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> * result_type=nullptr) const</td></tr>
<tr class="memdesc:aac3b5cb1dd19d79862b90ddc969946a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#aac3b5cb1dd19d79862b90ddc969946a6">More...</a><br /></td></tr>
<tr class="separator:aac3b5cb1dd19d79862b90ddc969946a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3535280c79cf5ba785dbde7ec25c71ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a3535280c79cf5ba785dbde7ec25c71ee">eval_to_string</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> * result_type=nullptr) const</td></tr>
<tr class="memdesc:a3535280c79cf5ba785dbde7ec25c71ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#a3535280c79cf5ba785dbde7ec25c71ee">More...</a><br /></td></tr>
<tr class="separator:a3535280c79cf5ba785dbde7ec25c71ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49686535bafb0f17cac3a3b12b8ce769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a49686535bafb0f17cac3a3b12b8ce769">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath)</td></tr>
<tr class="memdesc:a49686535bafb0f17cac3a3b12b8ce769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Node.html#a49686535bafb0f17cac3a3b12b8ce769">More...</a><br /></td></tr>
<tr class="separator:a49686535bafb0f17cac3a3b12b8ce769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8209b97d6a45847709f121bb75f1b144"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a8209b97d6a45847709f121bb75f1b144">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath) const</td></tr>
<tr class="memdesc:a8209b97d6a45847709f121bb75f1b144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Node.html#a8209b97d6a45847709f121bb75f1b144">More...</a><br /></td></tr>
<tr class="separator:a8209b97d6a45847709f121bb75f1b144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4676913f9287edf6ff7615ef9e7b611"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ab4676913f9287edf6ff7615ef9e7b611">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp; namespaces)</td></tr>
<tr class="memdesc:ab4676913f9287edf6ff7615ef9e7b611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Node.html#ab4676913f9287edf6ff7615ef9e7b611">More...</a><br /></td></tr>
<tr class="separator:ab4676913f9287edf6ff7615ef9e7b611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b8647c689a5b081ab526ffa4f1f7b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a48b8647c689a5b081ab526ffa4f1f7b9">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp; namespaces) const</td></tr>
<tr class="memdesc:a48b8647c689a5b081ab526ffa4f1f7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Node.html#a48b8647c689a5b081ab526ffa4f1f7b9">More...</a><br /></td></tr>
<tr class="separator:a48b8647c689a5b081ab526ffa4f1f7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ddea4c2314e086ef28d89436ab72a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html#aec484e80254d11ae0f7046e011287a18">NodeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a85ddea4c2314e086ef28d89436ab72a0">get_children</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a85ddea4c2314e086ef28d89436ab72a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of child nodes.  <a href="classxmlpp_1_1Node.html#a85ddea4c2314e086ef28d89436ab72a0">More...</a><br /></td></tr>
<tr class="separator:a85ddea4c2314e086ef28d89436ab72a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67efde594ecca38fb48465e2aee414fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html#a97f19f7f19c763f616eadb702680826f">const_NodeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a67efde594ecca38fb48465e2aee414fd">get_children</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()) const</td></tr>
<tr class="memdesc:a67efde594ecca38fb48465e2aee414fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of child nodes.  <a href="classxmlpp_1_1Node.html#a67efde594ecca38fb48465e2aee414fd">More...</a><br /></td></tr>
<tr class="separator:a67efde594ecca38fb48465e2aee414fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee68120e2ec8e345098461b7f9ead6b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aee68120e2ec8e345098461b7f9ead6b0">get_first_child</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:aee68120e2ec8e345098461b7f9ead6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first child of this node.  <a href="classxmlpp_1_1Node.html#aee68120e2ec8e345098461b7f9ead6b0">More...</a><br /></td></tr>
<tr class="separator:aee68120e2ec8e345098461b7f9ead6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5b6c0fe037c89ceb13aaee65acd2a9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a7d5b6c0fe037c89ceb13aaee65acd2a9">get_first_child</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()) const</td></tr>
<tr class="memdesc:a7d5b6c0fe037c89ceb13aaee65acd2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first child of this node.  <a href="classxmlpp_1_1Node.html#a7d5b6c0fe037c89ceb13aaee65acd2a9">More...</a><br /></td></tr>
<tr class="separator:a7d5b6c0fe037c89ceb13aaee65acd2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb268824e43544ae4c431192d0b64d6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#acb268824e43544ae4c431192d0b64d6c">get_line</a> () const</td></tr>
<tr class="memdesc:acb268824e43544ae4c431192d0b64d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover at what line number this node occurs in the XML file.  <a href="classxmlpp_1_1Node.html#acb268824e43544ae4c431192d0b64d6c">More...</a><br /></td></tr>
<tr class="separator:acb268824e43544ae4c431192d0b64d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241a2a8259f4d1f88a1ff350e4ec31a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a241a2a8259f4d1f88a1ff350e4ec31a3">get_name</a> () const</td></tr>
<tr class="memdesc:a241a2a8259f4d1f88a1ff350e4ec31a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this node.  <a href="classxmlpp_1_1Node.html#a241a2a8259f4d1f88a1ff350e4ec31a3">More...</a><br /></td></tr>
<tr class="separator:a241a2a8259f4d1f88a1ff350e4ec31a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04dc0c8607a0325cb91b97beb681560"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ad04dc0c8607a0325cb91b97beb681560">get_namespace_prefix</a> () const</td></tr>
<tr class="memdesc:ad04dc0c8607a0325cb91b97beb681560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the namespace prefix of this node.  <a href="classxmlpp_1_1Node.html#ad04dc0c8607a0325cb91b97beb681560">More...</a><br /></td></tr>
<tr class="separator:ad04dc0c8607a0325cb91b97beb681560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05daa979133adce46e25cfcee1de98c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a05daa979133adce46e25cfcee1de98c2">get_namespace_uri</a> () const</td></tr>
<tr class="memdesc:a05daa979133adce46e25cfcee1de98c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the namespace URI of this node.  <a href="classxmlpp_1_1Node.html#a05daa979133adce46e25cfcee1de98c2">More...</a><br /></td></tr>
<tr class="separator:a05daa979133adce46e25cfcee1de98c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2576ce35a6a3dd13b49e857524360ac4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a2576ce35a6a3dd13b49e857524360ac4">get_next_sibling</a> ()</td></tr>
<tr class="memdesc:a2576ce35a6a3dd13b49e857524360ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next sibling for this node.  <a href="classxmlpp_1_1Node.html#a2576ce35a6a3dd13b49e857524360ac4">More...</a><br /></td></tr>
<tr class="separator:a2576ce35a6a3dd13b49e857524360ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46801c7ceac58eef36b87e82b23fe171"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a46801c7ceac58eef36b87e82b23fe171">get_next_sibling</a> () const</td></tr>
<tr class="memdesc:a46801c7ceac58eef36b87e82b23fe171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next sibling for this node.  <a href="classxmlpp_1_1Node.html#a46801c7ceac58eef36b87e82b23fe171">More...</a><br /></td></tr>
<tr class="separator:a46801c7ceac58eef36b87e82b23fe171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998e8cb924bd04abf72e57b68d2817f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a998e8cb924bd04abf72e57b68d2817f4">get_parent</a> ()</td></tr>
<tr class="memdesc:a998e8cb924bd04abf72e57b68d2817f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent element for this node.  <a href="classxmlpp_1_1Node.html#a998e8cb924bd04abf72e57b68d2817f4">More...</a><br /></td></tr>
<tr class="separator:a998e8cb924bd04abf72e57b68d2817f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d1a5de2b8314c6588b23ddb83ac7e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxmlpp_1_1Element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a12d1a5de2b8314c6588b23ddb83ac7e5">get_parent</a> () const</td></tr>
<tr class="memdesc:a12d1a5de2b8314c6588b23ddb83ac7e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent element for this node.  <a href="classxmlpp_1_1Node.html#a12d1a5de2b8314c6588b23ddb83ac7e5">More...</a><br /></td></tr>
<tr class="separator:a12d1a5de2b8314c6588b23ddb83ac7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfeaacfd4bcd0737c31c07f23fe8e75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a9dfeaacfd4bcd0737c31c07f23fe8e75">get_path</a> () const</td></tr>
<tr class="memdesc:a9dfeaacfd4bcd0737c31c07f23fe8e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the XPath of this node.  <a href="classxmlpp_1_1Node.html#a9dfeaacfd4bcd0737c31c07f23fe8e75">More...</a><br /></td></tr>
<tr class="separator:a9dfeaacfd4bcd0737c31c07f23fe8e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567be4ebaffb2cd3dd2ae602c8df4a29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a567be4ebaffb2cd3dd2ae602c8df4a29">get_previous_sibling</a> ()</td></tr>
<tr class="memdesc:a567be4ebaffb2cd3dd2ae602c8df4a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the previous sibling for this node.  <a href="classxmlpp_1_1Node.html#a567be4ebaffb2cd3dd2ae602c8df4a29">More...</a><br /></td></tr>
<tr class="separator:a567be4ebaffb2cd3dd2ae602c8df4a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2169d1a0829acbc9a9ec5df4219b0b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a9c2169d1a0829acbc9a9ec5df4219b0b">get_previous_sibling</a> () const</td></tr>
<tr class="memdesc:a9c2169d1a0829acbc9a9ec5df4219b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the previous sibling for this node .  <a href="classxmlpp_1_1Node.html#a9c2169d1a0829acbc9a9ec5df4219b0b">More...</a><br /></td></tr>
<tr class="separator:a9c2169d1a0829acbc9a9ec5df4219b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea42eae72fa7901aa1fb8f5c0fd194ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aea42eae72fa7901aa1fb8f5c0fd194ec">import_node</a> (const <a class="el" href="classxmlpp_1_1Node.html">Node</a> * node, bool recursive=true)</td></tr>
<tr class="memdesc:aea42eae72fa7901aa1fb8f5c0fd194ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import node(s) from another document under this node, without affecting the source node.  <a href="classxmlpp_1_1Node.html#aea42eae72fa7901aa1fb8f5c0fd194ec">More...</a><br /></td></tr>
<tr class="separator:aea42eae72fa7901aa1fb8f5c0fd194ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57a323ddd24a12707e27efa26b2b7c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ab57a323ddd24a12707e27efa26b2b7c1">set_name</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name)</td></tr>
<tr class="memdesc:ab57a323ddd24a12707e27efa26b2b7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of this node.  <a href="classxmlpp_1_1Node.html#ab57a323ddd24a12707e27efa26b2b7c1">More...</a><br /></td></tr>
<tr class="separator:ab57a323ddd24a12707e27efa26b2b7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fb69ff6ff91d88996911da31ed5976"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ac7fb69ff6ff91d88996911da31ed5976">set_namespace</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix)</td></tr>
<tr class="memdesc:ac7fb69ff6ff91d88996911da31ed5976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the namespace prefix used by the node.  <a href="classxmlpp_1_1Node.html#ac7fb69ff6ff91d88996911da31ed5976">More...</a><br /></td></tr>
<tr class="separator:ac7fb69ff6ff91d88996911da31ed5976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxmlpp_1_1NonCopyable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxmlpp_1_1NonCopyable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxmlpp_1_1NonCopyable.html">xmlpp::NonCopyable</a></td></tr>
<tr class="memitem:aded750a42a8acdd5ed63827c158f7763 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#aded750a42a8acdd5ed63827c158f7763">NonCopyable</a> (const <a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a> &amp;)=delete</td></tr>
<tr class="separator:aded750a42a8acdd5ed63827c158f7763 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537645a43274a8d742eed00a35ffb917 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a537645a43274a8d742eed00a35ffb917">NonCopyable</a> (<a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a537645a43274a8d742eed00a35ffb917 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef35c286da3c2b8c90da9bb50aaddf1 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#adef35c286da3c2b8c90da9bb50aaddf1">operator=</a> (const <a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a> &amp;)=delete</td></tr>
<tr class="separator:adef35c286da3c2b8c90da9bb50aaddf1 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9888c9e5345760386ac57ff6439a30e4 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a9888c9e5345760386ac57ff6439a30e4">operator=</a> (<a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a9888c9e5345760386ac57ff6439a30e4 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a616a872d0fbd86206c0beee0be5abee3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a616a872d0fbd86206c0beee0be5abee3">create_wrapper</a> (_xmlNode * node)</td></tr>
<tr class="memdesc:a616a872d0fbd86206c0beee0be5abee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the correct C++ instance for a given libxml C struct instance.  <a href="classxmlpp_1_1Node.html#a616a872d0fbd86206c0beee0be5abee3">More...</a><br /></td></tr>
<tr class="separator:a616a872d0fbd86206c0beee0be5abee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47901df78305a685fc9682cd44290d6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aa47901df78305a685fc9682cd44290d6">free_wrappers</a> (_xmlNode * node)</td></tr>
<tr class="memdesc:aa47901df78305a685fc9682cd44290d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the C++ instance for a given libxml C struct instance, and also recursively destroy the C++ instances for any children.  <a href="classxmlpp_1_1Node.html#aa47901df78305a685fc9682cd44290d6">More...</a><br /></td></tr>
<tr class="separator:aa47901df78305a685fc9682cd44290d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3af70bdc909d8d272b3df0634fb291b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#af3af70bdc909d8d272b3df0634fb291b">remove_node</a> (<a class="el" href="classxmlpp_1_1Node.html">Node</a> * node)</td></tr>
<tr class="memdesc:af3af70bdc909d8d272b3df0634fb291b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node and its children.  <a href="classxmlpp_1_1Node.html#af3af70bdc909d8d272b3df0634fb291b">More...</a><br /></td></tr>
<tr class="separator:af3af70bdc909d8d272b3df0634fb291b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classxmlpp_1_1NonCopyable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classxmlpp_1_1NonCopyable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classxmlpp_1_1NonCopyable.html">xmlpp::NonCopyable</a></td></tr>
<tr class="memitem:a96e2e5582c5bb88b2dea2adb9f9512e2 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a96e2e5582c5bb88b2dea2adb9f9512e2">NonCopyable</a> () noexcept</td></tr>
<tr class="separator:a96e2e5582c5bb88b2dea2adb9f9512e2 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e2e0391beb4b8f20f5d51e8a253d63 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a14e2e0391beb4b8f20f5d51e8a253d63">~NonCopyable</a> ()</td></tr>
<tr class="separator:a14e2e0391beb4b8f20f5d51e8a253d63 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents XML Nodes. </p>
<p>You should never new and delete Nodes. The <a class="el" href="classxmlpp_1_1Parser.html" title="XML parser.">Parser</a> will create and manage them for you. Furthermore, <a class="el" href="classxmlpp_1_1Document.html" title="Represents an XML document in the DOM model.">Document</a> and <a class="el" href="classxmlpp_1_1Element.html" title="Element nodes have attributes as well as child nodes.">Element</a> have methods for adding Nodes to a <a class="el" href="classxmlpp_1_1Document.html" title="Represents an XML document in the DOM model.">Document</a>. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a97f19f7f19c763f616eadb702680826f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f19f7f19c763f616eadb702680826f">&#9670;&#160;</a></span>const_NodeList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Node.html#a97f19f7f19c763f616eadb702680826f">xmlpp::Node::const_NodeList</a> =  <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08383.html">std::list</a>&lt;const <a class="el" href="classxmlpp_1_1Node.html">Node</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57dba85e747dbe53ff768955bc3ca46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57dba85e747dbe53ff768955bc3ca46b">&#9670;&#160;</a></span>const_NodeSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">xmlpp::Node::const_NodeSet</a> =  <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08551.html">std::vector</a>&lt;const <a class="el" href="classxmlpp_1_1Node.html">Node</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec484e80254d11ae0f7046e011287a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec484e80254d11ae0f7046e011287a18">&#9670;&#160;</a></span>NodeList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Node.html#aec484e80254d11ae0f7046e011287a18">xmlpp::Node::NodeList</a> =  <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08383.html">std::list</a>&lt;<a class="el" href="classxmlpp_1_1Node.html">Node</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabbb1903a13e213fa94898a76518ebc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbb1903a13e213fa94898a76518ebc6">&#9670;&#160;</a></span>NodeSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">xmlpp::Node::NodeSet</a> =  <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08551.html">std::vector</a>&lt;<a class="el" href="classxmlpp_1_1Node.html">Node</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17584286cf6aea618a6d0878add65450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17584286cf6aea618a6d0878add65450">&#9670;&#160;</a></span>PrefixNsMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">xmlpp::Node::PrefixNsMap</a> =  <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08395.html">std::map</a>&lt;<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>, <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A map of namespace prefixes to namespace URIs. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a215d8c01b6b01596c4ea853f99dce8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215d8c01b6b01596c4ea853f99dce8e7">&#9670;&#160;</a></span>Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xmlpp::Node::Node </td>
          <td>(</td>
          <td class="paramtype">_xmlNode *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If <em>node</em> is <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed8dc1eea15e3e1ac42b43a49c3016ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8dc1eea15e3e1ac42b43a49c3016ba">&#9670;&#160;</a></span>~Node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xmlpp::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Does not destroy the underlying xmlNode. The xmlNode is owned by a xmlDoc document. If you want to also destroy the xmlNode, use <a class="el" href="classxmlpp_1_1Node.html#af3af70bdc909d8d272b3df0634fb291b" title="Remove a node and its children.">remove_node()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8d61ce066ad6ec4fca1e5637f7ec59a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d61ce066ad6ec4fca1e5637f7ec59a6">&#9670;&#160;</a></span>cobj() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const _xmlNode* xmlpp::Node::cobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the underlying libxml implementation. </p>

</div>
</div>
<a id="a648a236bfd53dcf4405446c8569d71b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648a236bfd53dcf4405446c8569d71b5">&#9670;&#160;</a></span>cobj() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_xmlNode* xmlpp::Node::cobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the underlying libxml implementation. </p>

</div>
</div>
<a id="a616a872d0fbd86206c0beee0be5abee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616a872d0fbd86206c0beee0be5abee3">&#9670;&#160;</a></span>create_wrapper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xmlpp::Node::create_wrapper </td>
          <td>(</td>
          <td class="paramtype">_xmlNode *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the correct C++ instance for a given libxml C struct instance. </p>
<p>This is only for use by the libxml++ implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A pointer to an xmlNode or a "derived" struct, such as xmlDoc, xmlAttr, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a259a1012c1a8cfb9c95ee51a7c3f9026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259a1012c1a8cfb9c95ee51a7c3f9026">&#9670;&#160;</a></span>eval_to_boolean() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xmlpp::Node::eval_to_boolean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> *&#160;</td>
          <td class="paramname"><em>result_type</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">xpath</td><td>The XPath expression. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">namespaces</td><td>A map of namespace prefixes to namespace URIs to be used while evaluating. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_type</td><td>Result type of the XPath expression before conversion to boolean. If <code>nullptr</code>, the result type is not returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the XPath expression. If the value is not of type boolean, it is converted to boolean. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000013">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a0762a2fda0ede4be6f6a4a23c2eb2ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0762a2fda0ede4be6f6a4a23c2eb2ae2">&#9670;&#160;</a></span>eval_to_boolean() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xmlpp::Node::eval_to_boolean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> *&#160;</td>
          <td class="paramname"><em>result_type</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">xpath</td><td>The XPath expression. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_type</td><td>Result type of the XPath expression before conversion to boolean. If <code>nullptr</code>, the result type is not returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the XPath expression. If the value is not of type boolean, it is converted to boolean. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000012">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="add6d8da74d2014427a929fbc0464a4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6d8da74d2014427a929fbc0464a4b8">&#9670;&#160;</a></span>eval_to_number() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double xmlpp::Node::eval_to_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> *&#160;</td>
          <td class="paramname"><em>result_type</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">xpath</td><td>The XPath expression. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">namespaces</td><td>A map of namespace prefixes to namespace URIs to be used while evaluating. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_type</td><td>Result type of the XPath expression before conversion to number. If <code>nullptr</code>, the result type is not returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the XPath expression. If the value is not of type number, it is converted to number. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000015">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a1485086156a31d55f9079031429c94a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1485086156a31d55f9079031429c94a7">&#9670;&#160;</a></span>eval_to_number() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double xmlpp::Node::eval_to_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> *&#160;</td>
          <td class="paramname"><em>result_type</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">xpath</td><td>The XPath expression. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_type</td><td>Result type of the XPath expression before conversion to number. If <code>nullptr</code>, the result type is not returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the XPath expression. If the value is not of type number, it is converted to number. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000014">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="aac3b5cb1dd19d79862b90ddc969946a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3b5cb1dd19d79862b90ddc969946a6">&#9670;&#160;</a></span>eval_to_string() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Node::eval_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> *&#160;</td>
          <td class="paramname"><em>result_type</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">xpath</td><td>The XPath expression. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">namespaces</td><td>A map of namespace prefixes to namespace URIs to be used while evaluating. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_type</td><td>Result type of the XPath expression before conversion to string. If <code>nullptr</code>, the result type is not returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the XPath expression. If the value is not of type string, it is converted to string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000017">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a3535280c79cf5ba785dbde7ec25c71ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3535280c79cf5ba785dbde7ec25c71ee">&#9670;&#160;</a></span>eval_to_string() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Node::eval_to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> *&#160;</td>
          <td class="paramname"><em>result_type</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">xpath</td><td>The XPath expression. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_type</td><td>Result type of the XPath expression before conversion to string. If <code>nullptr</code>, the result type is not returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the XPath expression. If the value is not of type string, it is converted to string. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000016">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a49686535bafb0f17cac3a3b12b8ce769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49686535bafb0f17cac3a3b12b8ce769">&#9670;&#160;</a></span>find() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a> xmlpp::Node::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>xpath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find nodes from an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xpath</td><td>The XPath of the nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting NodeSet. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If the result type is not nodeset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8209b97d6a45847709f121bb75f1b144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8209b97d6a45847709f121bb75f1b144">&#9670;&#160;</a></span>find() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a> xmlpp::Node::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>xpath</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find nodes from an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xpath</td><td>The XPath of the nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting const_NodeSet. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If the result type is not nodeset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4676913f9287edf6ff7615ef9e7b611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4676913f9287edf6ff7615ef9e7b611">&#9670;&#160;</a></span>find() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a> xmlpp::Node::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find nodes from an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xpath</td><td>The XPath of the nodes. </td></tr>
    <tr><td class="paramname">namespaces</td><td>A map of namespace prefixes to namespace URIs to be used while finding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting NodeSet. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If the result type is not nodeset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48b8647c689a5b081ab526ffa4f1f7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b8647c689a5b081ab526ffa4f1f7b9">&#9670;&#160;</a></span>find() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a> xmlpp::Node::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>xpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp;&#160;</td>
          <td class="paramname"><em>namespaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find nodes from an XPath expression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xpath</td><td>The XPath of the nodes. </td></tr>
    <tr><td class="paramname">namespaces</td><td>A map of namespace prefixes to namespace URIs to be used while finding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting const_NodeSet. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If the XPath expression cannot be evaluated. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If the result type is not nodeset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa47901df78305a685fc9682cd44290d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47901df78305a685fc9682cd44290d6">&#9670;&#160;</a></span>free_wrappers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xmlpp::Node::free_wrappers </td>
          <td>(</td>
          <td class="paramtype">_xmlNode *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the C++ instance for a given libxml C struct instance, and also recursively destroy the C++ instances for any children. </p>
<p>This is only for use by the libxml++ implementation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>A pointer to an xmlNode or a "derived" struct, such as xmlDoc, xmlAttr, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85ddea4c2314e086ef28d89436ab72a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ddea4c2314e086ef28d89436ab72a0">&#9670;&#160;</a></span>get_children() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html#aec484e80254d11ae0f7046e011287a18">NodeList</a> xmlpp::Node::get_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the list of child nodes. </p>
<p>You may optionally obtain a list of only the child nodes which have a certain name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The names of the child nodes to get. If you do not specify a name, then the list will contain all nodes, regardless of their names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of child nodes. </dd></dl>

</div>
</div>
<a id="a67efde594ecca38fb48465e2aee414fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67efde594ecca38fb48465e2aee414fd">&#9670;&#160;</a></span>get_children() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html#a97f19f7f19c763f616eadb702680826f">const_NodeList</a> xmlpp::Node::get_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the list of child nodes. </p>
<p>You may optionally obtain a list of only the child nodes which have a certain name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The names of the child nodes to get. If you do not specify a name, then the list will contain all nodes, regardless of their names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The list of child nodes. </dd></dl>

</div>
</div>
<a id="aee68120e2ec8e345098461b7f9ead6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee68120e2ec8e345098461b7f9ead6b0">&#9670;&#160;</a></span>get_first_child() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::get_first_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first child of this node. </p>
<p>You may optionally get the first child node which has a certain name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the requested child node, or an empty string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first child, or <code>nullptr</code> if no child node (with the specified name) exists.</dd></dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000011">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a7d5b6c0fe037c89ceb13aaee65acd2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5b6c0fe037c89ceb13aaee65acd2a9">&#9670;&#160;</a></span>get_first_child() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::get_first_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first child of this node. </p>
<p>You may optionally get the first child node which has a certain name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the requested child node, or an empty string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first child, or <code>nullptr</code> if no child node (with the specified name) exists.</dd></dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000010">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="acb268824e43544ae4c431192d0b64d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb268824e43544ae4c431192d0b64d6c">&#9670;&#160;</a></span>get_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xmlpp::Node::get_line </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover at what line number this node occurs in the XML file. </p>
<dl class="section return"><dt>Returns</dt><dd>The line number. </dd></dl>

</div>
</div>
<a id="a241a2a8259f4d1f88a1ff350e4ec31a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241a2a8259f4d1f88a1ff350e4ec31a3">&#9670;&#160;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Node::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the name of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The node's name. </dd></dl>

</div>
</div>
<a id="ad04dc0c8607a0325cb91b97beb681560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04dc0c8607a0325cb91b97beb681560">&#9670;&#160;</a></span>get_namespace_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Node::get_namespace_prefix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the namespace prefix of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The node's namespace prefix. Can be an empty string. </dd></dl>

</div>
</div>
<a id="a05daa979133adce46e25cfcee1de98c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05daa979133adce46e25cfcee1de98c2">&#9670;&#160;</a></span>get_namespace_uri()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Node::get_namespace_uri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the namespace URI of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The node's namespace URI. Can be an empty string. </dd></dl>

</div>
</div>
<a id="a2576ce35a6a3dd13b49e857524360ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2576ce35a6a3dd13b49e857524360ac4">&#9670;&#160;</a></span>get_next_sibling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::get_next_sibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next sibling for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The next sibling, or <code>nullptr</code> if the node has no next sibling. </dd></dl>

</div>
</div>
<a id="a46801c7ceac58eef36b87e82b23fe171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46801c7ceac58eef36b87e82b23fe171">&#9670;&#160;</a></span>get_next_sibling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::get_next_sibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next sibling for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The next sibling, or <code>nullptr</code> if the node has no next sibling. </dd></dl>

</div>
</div>
<a id="a998e8cb924bd04abf72e57b68d2817f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998e8cb924bd04abf72e57b68d2817f4">&#9670;&#160;</a></span>get_parent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Node::get_parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parent element for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The parent node, or <code>nullptr</code> if the node has no parent element. </dd></dl>

</div>
</div>
<a id="a12d1a5de2b8314c6588b23ddb83ac7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d1a5de2b8314c6588b23ddb83ac7e5">&#9670;&#160;</a></span>get_parent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Node::get_parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the parent element for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The parent node, or <code>nullptr</code> if the node has no parent element. </dd></dl>

</div>
</div>
<a id="a9dfeaacfd4bcd0737c31c07f23fe8e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dfeaacfd4bcd0737c31c07f23fe8e75">&#9670;&#160;</a></span>get_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Node::get_path </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the XPath of this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The XPath of the node. </dd></dl>

</div>
</div>
<a id="a567be4ebaffb2cd3dd2ae602c8df4a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a567be4ebaffb2cd3dd2ae602c8df4a29">&#9670;&#160;</a></span>get_previous_sibling() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::get_previous_sibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the previous sibling for this node. </p>
<dl class="section return"><dt>Returns</dt><dd>The previous sibling, or <code>nullptr</code> if the node has no previous sibling. </dd></dl>

</div>
</div>
<a id="a9c2169d1a0829acbc9a9ec5df4219b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2169d1a0829acbc9a9ec5df4219b0b">&#9670;&#160;</a></span>get_previous_sibling() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::get_previous_sibling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the previous sibling for this node . </p>
<dl class="section return"><dt>Returns</dt><dd>The previous sibling, or <code>nullptr</code> if the node has no previous sibling. </dd></dl>

</div>
</div>
<a id="aea42eae72fa7901aa1fb8f5c0fd194ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea42eae72fa7901aa1fb8f5c0fd194ec">&#9670;&#160;</a></span>import_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Node.html">Node</a>* xmlpp::Node::import_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Import node(s) from another document under this node, without affecting the source node. </p>
<p>If the imported node is an attribute node, and this node has an attribute with the same name as the imported attribute, the existing attribute is destroyed before the imported attribute is added. Any pointer to a destroyed attribute node becomes invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to copy and insert under the current node. </td></tr>
    <tr><td class="paramname">recursive</td><td>Whether to import the child nodes also. Defaults to true. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Usually the newly created node, but adjacent text nodes are merged, and the old text node with merged contents is returned. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3af70bdc909d8d272b3df0634fb291b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3af70bdc909d8d272b3df0634fb291b">&#9670;&#160;</a></span>remove_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void xmlpp::Node::remove_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a node and its children. </p>
<p>The node is disconnected from its parent. The underlying libxml xmlNode instances are also removed.</p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000020">Since libxml++ 3.0:</a></b></dt><dd>Replaces remove_child()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to remove. This <a class="el" href="classxmlpp_1_1Node.html" title="Represents XML Nodes.">Node</a> and all its descendants will be deleted and therefore unusable after calling this method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab57a323ddd24a12707e27efa26b2b7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57a323ddd24a12707e27efa26b2b7c1">&#9670;&#160;</a></span>set_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xmlpp::Node::set_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the name of this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The new name for the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7fb69ff6ff91d88996911da31ed5976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7fb69ff6ff91d88996911da31ed5976">&#9670;&#160;</a></span>set_namespace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xmlpp::Node::set_namespace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the namespace prefix used by the node. </p>
<p>If no such namespace prefix has been declared then this method will throw an exception. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns_prefix</td><td>The namespace prefix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 22 2023 13:16:31 for libxml++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
