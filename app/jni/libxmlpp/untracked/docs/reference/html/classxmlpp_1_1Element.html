<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libxml++: xmlpp::Element Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libxml++
   &#160;<span id="projectnumber">5.0.3</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacexmlpp.html">xmlpp</a></li><li class="navelem"><a class="el" href="classxmlpp_1_1Element.html">Element</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classxmlpp_1_1Element-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">xmlpp::Element Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Element nodes have attributes as well as child nodes.  
 <a href="classxmlpp_1_1Element.html#details">More...</a></p>

<p><code>#include &lt;libxml++/nodes/element.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for xmlpp::Element:</div>
<div class="dyncontent">
<div class="center"><img src="classxmlpp_1_1Element__inherit__graph.png" border="0" usemap="#axmlpp_1_1Element_inherit__map" alt="Inheritance graph"/></div>
<map name="axmlpp_1_1Element_inherit__map" id="axmlpp_1_1Element_inherit__map">
<area shape="rect" title="Element nodes have attributes as well as child nodes." alt="" coords="22,155,147,181"/>
<area shape="rect" href="classxmlpp_1_1Node.html" title="Represents XML Nodes." alt="" coords="32,80,137,107"/>
<area shape="rect" href="classxmlpp_1_1NonCopyable.html" title="A base for classes which cannot be copied or moved." alt="" coords="5,5,164,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a74581b2c25aaa277cf0153af74fcbc31"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a74581b2c25aaa277cf0153af74fcbc31">AttributeList</a> = <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08383.html">std::list</a>&lt; <a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a> * &gt;</td></tr>
<tr class="separator:a74581b2c25aaa277cf0153af74fcbc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2a056f183f2c3ddeb1ddf5a9316006"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#afb2a056f183f2c3ddeb1ddf5a9316006">const_AttributeList</a> = <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08383.html">std::list</a>&lt; const <a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a> * &gt;</td></tr>
<tr class="separator:afb2a056f183f2c3ddeb1ddf5a9316006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classxmlpp_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classxmlpp_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a></td></tr>
<tr class="memitem:a97f19f7f19c763f616eadb702680826f inherit pub_types_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a97f19f7f19c763f616eadb702680826f">const_NodeList</a> = <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08383.html">std::list</a>&lt; const <a class="el" href="classxmlpp_1_1Node.html">Node</a> * &gt;</td></tr>
<tr class="separator:a97f19f7f19c763f616eadb702680826f inherit pub_types_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dba85e747dbe53ff768955bc3ca46b inherit pub_types_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a> = <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08551.html">std::vector</a>&lt; const <a class="el" href="classxmlpp_1_1Node.html">Node</a> * &gt;</td></tr>
<tr class="separator:a57dba85e747dbe53ff768955bc3ca46b inherit pub_types_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec484e80254d11ae0f7046e011287a18 inherit pub_types_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aec484e80254d11ae0f7046e011287a18">NodeList</a> = <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08383.html">std::list</a>&lt; <a class="el" href="classxmlpp_1_1Node.html">Node</a> * &gt;</td></tr>
<tr class="separator:aec484e80254d11ae0f7046e011287a18 inherit pub_types_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbb1903a13e213fa94898a76518ebc6 inherit pub_types_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a> = <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08551.html">std::vector</a>&lt; <a class="el" href="classxmlpp_1_1Node.html">Node</a> * &gt;</td></tr>
<tr class="separator:aabbb1903a13e213fa94898a76518ebc6 inherit pub_types_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17584286cf6aea618a6d0878add65450 inherit pub_types_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> = <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08395.html">std::map</a>&lt; <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>, <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &gt;</td></tr>
<tr class="memdesc:a17584286cf6aea618a6d0878add65450 inherit pub_types_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">A map of namespace prefixes to namespace URIs.  <a href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">More...</a><br /></td></tr>
<tr class="separator:a17584286cf6aea618a6d0878add65450 inherit pub_types_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:addce07f26b8ca52beb583d942375a756"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#addce07f26b8ca52beb583d942375a756">Element</a> (_xmlNode * node)</td></tr>
<tr class="separator:addce07f26b8ca52beb583d942375a756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdba1990c4620a4b02b4fcd4a4afa2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a2cdba1990c4620a4b02b4fcd4a4afa2d">~Element</a> () override</td></tr>
<tr class="separator:a2cdba1990c4620a4b02b4fcd4a4afa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b7f4040d66fc847a1040ae961b923d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1CdataNode.html">CdataNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a45b7f4040d66fc847a1040ae961b923d">add_child_cdata</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; content)</td></tr>
<tr class="memdesc:a45b7f4040d66fc847a1040ae961b923d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a new CDATA node.  <a href="classxmlpp_1_1Element.html#a45b7f4040d66fc847a1040ae961b923d">More...</a><br /></td></tr>
<tr class="separator:a45b7f4040d66fc847a1040ae961b923d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee69d63061e05c765d32a686a4434d9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1CommentNode.html">CommentNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#aee69d63061e05c765d32a686a4434d9d">add_child_comment</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; content)</td></tr>
<tr class="memdesc:aee69d63061e05c765d32a686a4434d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a new comment node.  <a href="classxmlpp_1_1Element.html#aee69d63061e05c765d32a686a4434d9d">More...</a><br /></td></tr>
<tr class="separator:aee69d63061e05c765d32a686a4434d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3e495a0766d81b5a83e7a3146da683"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#aec3e495a0766d81b5a83e7a3146da683">add_child_element</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:aec3e495a0766d81b5a83e7a3146da683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child element to this node.  <a href="classxmlpp_1_1Element.html#aec3e495a0766d81b5a83e7a3146da683">More...</a><br /></td></tr>
<tr class="separator:aec3e495a0766d81b5a83e7a3146da683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada475bd91e7deb727aba6fa99f9d1a1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#ada475bd91e7deb727aba6fa99f9d1a1b">add_child_element</a> (<a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a> * previous_sibling, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:ada475bd91e7deb727aba6fa99f9d1a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child element to this node after the specified existing child node.  <a href="classxmlpp_1_1Element.html#ada475bd91e7deb727aba6fa99f9d1a1b">More...</a><br /></td></tr>
<tr class="separator:ada475bd91e7deb727aba6fa99f9d1a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ecc3e0312fc29a49aa9b471a947a19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#ab5ecc3e0312fc29a49aa9b471a947a19">add_child_element_before</a> (<a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a> * next_sibling, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:ab5ecc3e0312fc29a49aa9b471a947a19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child element to this node before the specified existing child node.  <a href="classxmlpp_1_1Element.html#ab5ecc3e0312fc29a49aa9b471a947a19">More...</a><br /></td></tr>
<tr class="separator:ab5ecc3e0312fc29a49aa9b471a947a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853ac21a9510bbdef9d829dfb6d14dfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a853ac21a9510bbdef9d829dfb6d14dfd">add_child_element_before_with_new_ns</a> (<a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a> * next_sibling, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_uri, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a853ac21a9510bbdef9d829dfb6d14dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child element to this node before the specified existing child node.  <a href="classxmlpp_1_1Element.html#a853ac21a9510bbdef9d829dfb6d14dfd">More...</a><br /></td></tr>
<tr class="separator:a853ac21a9510bbdef9d829dfb6d14dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d344410c6deb3eee2a1bb9bc478375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a04d344410c6deb3eee2a1bb9bc478375">add_child_element_with_new_ns</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_uri, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a04d344410c6deb3eee2a1bb9bc478375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child element to this node.  <a href="classxmlpp_1_1Element.html#a04d344410c6deb3eee2a1bb9bc478375">More...</a><br /></td></tr>
<tr class="separator:a04d344410c6deb3eee2a1bb9bc478375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad850fef0eb9000bc858e5b2dc0e55092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#ad850fef0eb9000bc858e5b2dc0e55092">add_child_element_with_new_ns</a> (<a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a> * previous_sibling, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_uri, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:ad850fef0eb9000bc858e5b2dc0e55092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a child element to this node after the specified existing child node.  <a href="classxmlpp_1_1Element.html#ad850fef0eb9000bc858e5b2dc0e55092">More...</a><br /></td></tr>
<tr class="separator:ad850fef0eb9000bc858e5b2dc0e55092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775c3a4b5da4d168376b0a61a1ad2040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1EntityReference.html">EntityReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a775c3a4b5da4d168376b0a61a1ad2040">add_child_entity_reference</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name)</td></tr>
<tr class="memdesc:a775c3a4b5da4d168376b0a61a1ad2040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a new entity reference node.  <a href="classxmlpp_1_1Element.html#a775c3a4b5da4d168376b0a61a1ad2040">More...</a><br /></td></tr>
<tr class="separator:a775c3a4b5da4d168376b0a61a1ad2040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180c2e543c9ad54d352f364ad8241622"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1ProcessingInstructionNode.html">ProcessingInstructionNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a180c2e543c9ad54d352f364ad8241622">add_child_processing_instruction</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; content)</td></tr>
<tr class="memdesc:a180c2e543c9ad54d352f364ad8241622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a new processing instruction node.  <a href="classxmlpp_1_1Element.html#a180c2e543c9ad54d352f364ad8241622">More...</a><br /></td></tr>
<tr class="separator:a180c2e543c9ad54d352f364ad8241622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29128571895c5f7b77382ed69c18726c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a29128571895c5f7b77382ed69c18726c">add_child_text</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; content=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a29128571895c5f7b77382ed69c18726c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a new text node.  <a href="classxmlpp_1_1Element.html#a29128571895c5f7b77382ed69c18726c">More...</a><br /></td></tr>
<tr class="separator:a29128571895c5f7b77382ed69c18726c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe27ad61606dac9da274c8b43c5708aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#afe27ad61606dac9da274c8b43c5708aa">add_child_text</a> (<a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a> * previous_sibling, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; content=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:afe27ad61606dac9da274c8b43c5708aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new text node after the specified existing child node.  <a href="classxmlpp_1_1Element.html#afe27ad61606dac9da274c8b43c5708aa">More...</a><br /></td></tr>
<tr class="separator:afe27ad61606dac9da274c8b43c5708aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67870433ece791c1204aef49d4348319"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a67870433ece791c1204aef49d4348319">add_child_text_before</a> (<a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a> * next_sibling, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; content=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a67870433ece791c1204aef49d4348319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new text node before the specified existing child node.  <a href="classxmlpp_1_1Element.html#a67870433ece791c1204aef49d4348319">More...</a><br /></td></tr>
<tr class="separator:a67870433ece791c1204aef49d4348319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5786c9bbdcb50b0defe8cfb4e51c1fca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a5786c9bbdcb50b0defe8cfb4e51c1fca">get_attribute</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a5786c9bbdcb50b0defe8cfb4e51c1fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the attribute with this name, and optionally with this namespace.  <a href="classxmlpp_1_1Element.html#a5786c9bbdcb50b0defe8cfb4e51c1fca">More...</a><br /></td></tr>
<tr class="separator:a5786c9bbdcb50b0defe8cfb4e51c1fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd49ca593243f4d30b9fae7cc14175b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a4cd49ca593243f4d30b9fae7cc14175b">get_attribute</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()) const</td></tr>
<tr class="memdesc:a4cd49ca593243f4d30b9fae7cc14175b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the attribute with this name, and optionally with this namespace.  <a href="classxmlpp_1_1Element.html#a4cd49ca593243f4d30b9fae7cc14175b">More...</a><br /></td></tr>
<tr class="separator:a4cd49ca593243f4d30b9fae7cc14175b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d704c3d807bc55f47945e3da7ee1428"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a4d704c3d807bc55f47945e3da7ee1428">get_attribute_value</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()) const</td></tr>
<tr class="memdesc:a4d704c3d807bc55f47945e3da7ee1428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value of the attribute with this name, and optionally with this namespace.  <a href="classxmlpp_1_1Element.html#a4d704c3d807bc55f47945e3da7ee1428">More...</a><br /></td></tr>
<tr class="separator:a4d704c3d807bc55f47945e3da7ee1428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbb85e7ecabc5a8b9b39638f94e4fb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Element.html#a74581b2c25aaa277cf0153af74fcbc31">AttributeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a8fbb85e7ecabc5a8b9b39638f94e4fb7">get_attributes</a> ()</td></tr>
<tr class="memdesc:a8fbb85e7ecabc5a8b9b39638f94e4fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of explicitly set attributes for this element.  <a href="classxmlpp_1_1Element.html#a8fbb85e7ecabc5a8b9b39638f94e4fb7">More...</a><br /></td></tr>
<tr class="separator:a8fbb85e7ecabc5a8b9b39638f94e4fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215ca85858f1c51648a153a9c03154d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Element.html#afb2a056f183f2c3ddeb1ddf5a9316006">const_AttributeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a215ca85858f1c51648a153a9c03154d7">get_attributes</a> () const</td></tr>
<tr class="memdesc:a215ca85858f1c51648a153a9c03154d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of explicitly set attributes for this element.  <a href="classxmlpp_1_1Element.html#a215ca85858f1c51648a153a9c03154d7">More...</a><br /></td></tr>
<tr class="separator:a215ca85858f1c51648a153a9c03154d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69d8c22b51bcfddebc1b52d0739db8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#ab69d8c22b51bcfddebc1b52d0739db8c">get_first_child_text</a> ()</td></tr>
<tr class="memdesc:ab69d8c22b51bcfddebc1b52d0739db8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first child text content node.  <a href="classxmlpp_1_1Element.html#ab69d8c22b51bcfddebc1b52d0739db8c">More...</a><br /></td></tr>
<tr class="separator:ab69d8c22b51bcfddebc1b52d0739db8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbda06fa105905e7e138585946ddd6e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a3dbda06fa105905e7e138585946ddd6e">get_first_child_text</a> () const</td></tr>
<tr class="memdesc:a3dbda06fa105905e7e138585946ddd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first child text content node.  <a href="classxmlpp_1_1Element.html#a3dbda06fa105905e7e138585946ddd6e">More...</a><br /></td></tr>
<tr class="separator:a3dbda06fa105905e7e138585946ddd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf163cefbd08210bdb3c00598ef4164f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#aaf163cefbd08210bdb3c00598ef4164f">has_child_text</a> () const</td></tr>
<tr class="memdesc:aaf163cefbd08210bdb3c00598ef4164f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover whether one of the child nodes is a text node.  <a href="classxmlpp_1_1Element.html#aaf163cefbd08210bdb3c00598ef4164f">More...</a><br /></td></tr>
<tr class="separator:aaf163cefbd08210bdb3c00598ef4164f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9959d2eba5aaaf5f98086a6f560a7469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a9959d2eba5aaaf5f98086a6f560a7469">remove_attribute</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a9959d2eba5aaaf5f98086a6f560a7469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the attribute with this name, and optionally with this namespace.  <a href="classxmlpp_1_1Element.html#a9959d2eba5aaaf5f98086a6f560a7469">More...</a><br /></td></tr>
<tr class="separator:a9959d2eba5aaaf5f98086a6f560a7469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b29402f1d61113d8a8929f28d106d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#ac9b29402f1d61113d8a8929f28d106d8">set_attribute</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; value, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:ac9b29402f1d61113d8a8929f28d106d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the attribute with this name, and optionally with this namespace.  <a href="classxmlpp_1_1Element.html#ac9b29402f1d61113d8a8929f28d106d8">More...</a><br /></td></tr>
<tr class="separator:ac9b29402f1d61113d8a8929f28d106d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b60b87a98064e053c75098c74887e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a16b60b87a98064e053c75098c74887e7">set_first_child_text</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; content)</td></tr>
<tr class="memdesc:a16b60b87a98064e053c75098c74887e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the text of the first text node, adding one if necessary.  <a href="classxmlpp_1_1Element.html#a16b60b87a98064e053c75098c74887e7">More...</a><br /></td></tr>
<tr class="separator:a16b60b87a98064e053c75098c74887e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff97d55a647c9d3ac8ea77b978124d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Element.html#a4ff97d55a647c9d3ac8ea77b978124d1">set_namespace_declaration</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_uri, const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a4ff97d55a647c9d3ac8ea77b978124d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a namespace declaration to this node which will apply to this node and all children.  <a href="classxmlpp_1_1Element.html#a4ff97d55a647c9d3ac8ea77b978124d1">More...</a><br /></td></tr>
<tr class="separator:a4ff97d55a647c9d3ac8ea77b978124d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxmlpp_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxmlpp_1_1Node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a></td></tr>
<tr class="memitem:a215d8c01b6b01596c4ea853f99dce8e7 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a215d8c01b6b01596c4ea853f99dce8e7">Node</a> (_xmlNode * node)</td></tr>
<tr class="separator:a215d8c01b6b01596c4ea853f99dce8e7 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8dc1eea15e3e1ac42b43a49c3016ba inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aed8dc1eea15e3e1ac42b43a49c3016ba">~Node</a> () override</td></tr>
<tr class="memdesc:aed8dc1eea15e3e1ac42b43a49c3016ba inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classxmlpp_1_1Node.html#aed8dc1eea15e3e1ac42b43a49c3016ba">More...</a><br /></td></tr>
<tr class="separator:aed8dc1eea15e3e1ac42b43a49c3016ba inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d61ce066ad6ec4fca1e5637f7ec59a6 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">const _xmlNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a8d61ce066ad6ec4fca1e5637f7ec59a6">cobj</a> () const noexcept</td></tr>
<tr class="memdesc:a8d61ce066ad6ec4fca1e5637f7ec59a6 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the underlying libxml implementation.  <a href="classxmlpp_1_1Node.html#a8d61ce066ad6ec4fca1e5637f7ec59a6">More...</a><br /></td></tr>
<tr class="separator:a8d61ce066ad6ec4fca1e5637f7ec59a6 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648a236bfd53dcf4405446c8569d71b5 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">_xmlNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a648a236bfd53dcf4405446c8569d71b5">cobj</a> () noexcept</td></tr>
<tr class="memdesc:a648a236bfd53dcf4405446c8569d71b5 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the underlying libxml implementation.  <a href="classxmlpp_1_1Node.html#a648a236bfd53dcf4405446c8569d71b5">More...</a><br /></td></tr>
<tr class="separator:a648a236bfd53dcf4405446c8569d71b5 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259a1012c1a8cfb9c95ee51a7c3f9026 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a259a1012c1a8cfb9c95ee51a7c3f9026">eval_to_boolean</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp; namespaces, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> * result_type=nullptr) const</td></tr>
<tr class="memdesc:a259a1012c1a8cfb9c95ee51a7c3f9026 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#a259a1012c1a8cfb9c95ee51a7c3f9026">More...</a><br /></td></tr>
<tr class="separator:a259a1012c1a8cfb9c95ee51a7c3f9026 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0762a2fda0ede4be6f6a4a23c2eb2ae2 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a0762a2fda0ede4be6f6a4a23c2eb2ae2">eval_to_boolean</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> * result_type=nullptr) const</td></tr>
<tr class="memdesc:a0762a2fda0ede4be6f6a4a23c2eb2ae2 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#a0762a2fda0ede4be6f6a4a23c2eb2ae2">More...</a><br /></td></tr>
<tr class="separator:a0762a2fda0ede4be6f6a4a23c2eb2ae2 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6d8da74d2014427a929fbc0464a4b8 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#add6d8da74d2014427a929fbc0464a4b8">eval_to_number</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp; namespaces, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> * result_type=nullptr) const</td></tr>
<tr class="memdesc:add6d8da74d2014427a929fbc0464a4b8 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#add6d8da74d2014427a929fbc0464a4b8">More...</a><br /></td></tr>
<tr class="separator:add6d8da74d2014427a929fbc0464a4b8 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1485086156a31d55f9079031429c94a7 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a1485086156a31d55f9079031429c94a7">eval_to_number</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> * result_type=nullptr) const</td></tr>
<tr class="memdesc:a1485086156a31d55f9079031429c94a7 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#a1485086156a31d55f9079031429c94a7">More...</a><br /></td></tr>
<tr class="separator:a1485086156a31d55f9079031429c94a7 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3b5cb1dd19d79862b90ddc969946a6 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aac3b5cb1dd19d79862b90ddc969946a6">eval_to_string</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp; namespaces, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> * result_type=nullptr) const</td></tr>
<tr class="memdesc:aac3b5cb1dd19d79862b90ddc969946a6 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#aac3b5cb1dd19d79862b90ddc969946a6">More...</a><br /></td></tr>
<tr class="separator:aac3b5cb1dd19d79862b90ddc969946a6 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3535280c79cf5ba785dbde7ec25c71ee inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a3535280c79cf5ba785dbde7ec25c71ee">eval_to_string</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, <a class="el" href="namespacexmlpp.html#ac91075edf569a213343d7d13ae4be3c8">XPathResultType</a> * result_type=nullptr) const</td></tr>
<tr class="memdesc:a3535280c79cf5ba785dbde7ec25c71ee inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate an XPath expression.  <a href="classxmlpp_1_1Node.html#a3535280c79cf5ba785dbde7ec25c71ee">More...</a><br /></td></tr>
<tr class="separator:a3535280c79cf5ba785dbde7ec25c71ee inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49686535bafb0f17cac3a3b12b8ce769 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a49686535bafb0f17cac3a3b12b8ce769">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath)</td></tr>
<tr class="memdesc:a49686535bafb0f17cac3a3b12b8ce769 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Node.html#a49686535bafb0f17cac3a3b12b8ce769">More...</a><br /></td></tr>
<tr class="separator:a49686535bafb0f17cac3a3b12b8ce769 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8209b97d6a45847709f121bb75f1b144 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a8209b97d6a45847709f121bb75f1b144">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath) const</td></tr>
<tr class="memdesc:a8209b97d6a45847709f121bb75f1b144 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Node.html#a8209b97d6a45847709f121bb75f1b144">More...</a><br /></td></tr>
<tr class="separator:a8209b97d6a45847709f121bb75f1b144 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4676913f9287edf6ff7615ef9e7b611 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html#aabbb1903a13e213fa94898a76518ebc6">NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ab4676913f9287edf6ff7615ef9e7b611">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp; namespaces)</td></tr>
<tr class="memdesc:ab4676913f9287edf6ff7615ef9e7b611 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Node.html#ab4676913f9287edf6ff7615ef9e7b611">More...</a><br /></td></tr>
<tr class="separator:ab4676913f9287edf6ff7615ef9e7b611 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b8647c689a5b081ab526ffa4f1f7b9 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html#a57dba85e747dbe53ff768955bc3ca46b">const_NodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a48b8647c689a5b081ab526ffa4f1f7b9">find</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; xpath, const <a class="el" href="classxmlpp_1_1Node.html#a17584286cf6aea618a6d0878add65450">PrefixNsMap</a> &amp; namespaces) const</td></tr>
<tr class="memdesc:a48b8647c689a5b081ab526ffa4f1f7b9 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find nodes from an XPath expression.  <a href="classxmlpp_1_1Node.html#a48b8647c689a5b081ab526ffa4f1f7b9">More...</a><br /></td></tr>
<tr class="separator:a48b8647c689a5b081ab526ffa4f1f7b9 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ddea4c2314e086ef28d89436ab72a0 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html#aec484e80254d11ae0f7046e011287a18">NodeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a85ddea4c2314e086ef28d89436ab72a0">get_children</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:a85ddea4c2314e086ef28d89436ab72a0 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of child nodes.  <a href="classxmlpp_1_1Node.html#a85ddea4c2314e086ef28d89436ab72a0">More...</a><br /></td></tr>
<tr class="separator:a85ddea4c2314e086ef28d89436ab72a0 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67efde594ecca38fb48465e2aee414fd inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html#a97f19f7f19c763f616eadb702680826f">const_NodeList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a67efde594ecca38fb48465e2aee414fd">get_children</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()) const</td></tr>
<tr class="memdesc:a67efde594ecca38fb48465e2aee414fd inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of child nodes.  <a href="classxmlpp_1_1Node.html#a67efde594ecca38fb48465e2aee414fd">More...</a><br /></td></tr>
<tr class="separator:a67efde594ecca38fb48465e2aee414fd inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee68120e2ec8e345098461b7f9ead6b0 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aee68120e2ec8e345098461b7f9ead6b0">get_first_child</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>())</td></tr>
<tr class="memdesc:aee68120e2ec8e345098461b7f9ead6b0 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first child of this node.  <a href="classxmlpp_1_1Node.html#aee68120e2ec8e345098461b7f9ead6b0">More...</a><br /></td></tr>
<tr class="separator:aee68120e2ec8e345098461b7f9ead6b0 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5b6c0fe037c89ceb13aaee65acd2a9 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a7d5b6c0fe037c89ceb13aaee65acd2a9">get_first_child</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name=<a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()) const</td></tr>
<tr class="memdesc:a7d5b6c0fe037c89ceb13aaee65acd2a9 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first child of this node.  <a href="classxmlpp_1_1Node.html#a7d5b6c0fe037c89ceb13aaee65acd2a9">More...</a><br /></td></tr>
<tr class="separator:a7d5b6c0fe037c89ceb13aaee65acd2a9 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb268824e43544ae4c431192d0b64d6c inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#acb268824e43544ae4c431192d0b64d6c">get_line</a> () const</td></tr>
<tr class="memdesc:acb268824e43544ae4c431192d0b64d6c inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discover at what line number this node occurs in the XML file.  <a href="classxmlpp_1_1Node.html#acb268824e43544ae4c431192d0b64d6c">More...</a><br /></td></tr>
<tr class="separator:acb268824e43544ae4c431192d0b64d6c inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241a2a8259f4d1f88a1ff350e4ec31a3 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a241a2a8259f4d1f88a1ff350e4ec31a3">get_name</a> () const</td></tr>
<tr class="memdesc:a241a2a8259f4d1f88a1ff350e4ec31a3 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this node.  <a href="classxmlpp_1_1Node.html#a241a2a8259f4d1f88a1ff350e4ec31a3">More...</a><br /></td></tr>
<tr class="separator:a241a2a8259f4d1f88a1ff350e4ec31a3 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04dc0c8607a0325cb91b97beb681560 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ad04dc0c8607a0325cb91b97beb681560">get_namespace_prefix</a> () const</td></tr>
<tr class="memdesc:ad04dc0c8607a0325cb91b97beb681560 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the namespace prefix of this node.  <a href="classxmlpp_1_1Node.html#ad04dc0c8607a0325cb91b97beb681560">More...</a><br /></td></tr>
<tr class="separator:ad04dc0c8607a0325cb91b97beb681560 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05daa979133adce46e25cfcee1de98c2 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a05daa979133adce46e25cfcee1de98c2">get_namespace_uri</a> () const</td></tr>
<tr class="memdesc:a05daa979133adce46e25cfcee1de98c2 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the namespace URI of this node.  <a href="classxmlpp_1_1Node.html#a05daa979133adce46e25cfcee1de98c2">More...</a><br /></td></tr>
<tr class="separator:a05daa979133adce46e25cfcee1de98c2 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2576ce35a6a3dd13b49e857524360ac4 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a2576ce35a6a3dd13b49e857524360ac4">get_next_sibling</a> ()</td></tr>
<tr class="memdesc:a2576ce35a6a3dd13b49e857524360ac4 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next sibling for this node.  <a href="classxmlpp_1_1Node.html#a2576ce35a6a3dd13b49e857524360ac4">More...</a><br /></td></tr>
<tr class="separator:a2576ce35a6a3dd13b49e857524360ac4 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46801c7ceac58eef36b87e82b23fe171 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a46801c7ceac58eef36b87e82b23fe171">get_next_sibling</a> () const</td></tr>
<tr class="memdesc:a46801c7ceac58eef36b87e82b23fe171 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next sibling for this node.  <a href="classxmlpp_1_1Node.html#a46801c7ceac58eef36b87e82b23fe171">More...</a><br /></td></tr>
<tr class="separator:a46801c7ceac58eef36b87e82b23fe171 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998e8cb924bd04abf72e57b68d2817f4 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a998e8cb924bd04abf72e57b68d2817f4">get_parent</a> ()</td></tr>
<tr class="memdesc:a998e8cb924bd04abf72e57b68d2817f4 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent element for this node.  <a href="classxmlpp_1_1Node.html#a998e8cb924bd04abf72e57b68d2817f4">More...</a><br /></td></tr>
<tr class="separator:a998e8cb924bd04abf72e57b68d2817f4 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d1a5de2b8314c6588b23ddb83ac7e5 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxmlpp_1_1Element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a12d1a5de2b8314c6588b23ddb83ac7e5">get_parent</a> () const</td></tr>
<tr class="memdesc:a12d1a5de2b8314c6588b23ddb83ac7e5 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the parent element for this node.  <a href="classxmlpp_1_1Node.html#a12d1a5de2b8314c6588b23ddb83ac7e5">More...</a><br /></td></tr>
<tr class="separator:a12d1a5de2b8314c6588b23ddb83ac7e5 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfeaacfd4bcd0737c31c07f23fe8e75 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a9dfeaacfd4bcd0737c31c07f23fe8e75">get_path</a> () const</td></tr>
<tr class="memdesc:a9dfeaacfd4bcd0737c31c07f23fe8e75 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the XPath of this node.  <a href="classxmlpp_1_1Node.html#a9dfeaacfd4bcd0737c31c07f23fe8e75">More...</a><br /></td></tr>
<tr class="separator:a9dfeaacfd4bcd0737c31c07f23fe8e75 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567be4ebaffb2cd3dd2ae602c8df4a29 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a567be4ebaffb2cd3dd2ae602c8df4a29">get_previous_sibling</a> ()</td></tr>
<tr class="memdesc:a567be4ebaffb2cd3dd2ae602c8df4a29 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the previous sibling for this node.  <a href="classxmlpp_1_1Node.html#a567be4ebaffb2cd3dd2ae602c8df4a29">More...</a><br /></td></tr>
<tr class="separator:a567be4ebaffb2cd3dd2ae602c8df4a29 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2169d1a0829acbc9a9ec5df4219b0b inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a9c2169d1a0829acbc9a9ec5df4219b0b">get_previous_sibling</a> () const</td></tr>
<tr class="memdesc:a9c2169d1a0829acbc9a9ec5df4219b0b inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the previous sibling for this node .  <a href="classxmlpp_1_1Node.html#a9c2169d1a0829acbc9a9ec5df4219b0b">More...</a><br /></td></tr>
<tr class="separator:a9c2169d1a0829acbc9a9ec5df4219b0b inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea42eae72fa7901aa1fb8f5c0fd194ec inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aea42eae72fa7901aa1fb8f5c0fd194ec">import_node</a> (const <a class="el" href="classxmlpp_1_1Node.html">Node</a> * node, bool recursive=true)</td></tr>
<tr class="memdesc:aea42eae72fa7901aa1fb8f5c0fd194ec inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Import node(s) from another document under this node, without affecting the source node.  <a href="classxmlpp_1_1Node.html#aea42eae72fa7901aa1fb8f5c0fd194ec">More...</a><br /></td></tr>
<tr class="separator:aea42eae72fa7901aa1fb8f5c0fd194ec inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57a323ddd24a12707e27efa26b2b7c1 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ab57a323ddd24a12707e27efa26b2b7c1">set_name</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; name)</td></tr>
<tr class="memdesc:ab57a323ddd24a12707e27efa26b2b7c1 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the name of this node.  <a href="classxmlpp_1_1Node.html#ab57a323ddd24a12707e27efa26b2b7c1">More...</a><br /></td></tr>
<tr class="separator:ab57a323ddd24a12707e27efa26b2b7c1 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fb69ff6ff91d88996911da31ed5976 inherit pub_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#ac7fb69ff6ff91d88996911da31ed5976">set_namespace</a> (const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp; ns_prefix)</td></tr>
<tr class="memdesc:ac7fb69ff6ff91d88996911da31ed5976 inherit pub_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the namespace prefix used by the node.  <a href="classxmlpp_1_1Node.html#ac7fb69ff6ff91d88996911da31ed5976">More...</a><br /></td></tr>
<tr class="separator:ac7fb69ff6ff91d88996911da31ed5976 inherit pub_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classxmlpp_1_1NonCopyable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classxmlpp_1_1NonCopyable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classxmlpp_1_1NonCopyable.html">xmlpp::NonCopyable</a></td></tr>
<tr class="memitem:aded750a42a8acdd5ed63827c158f7763 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#aded750a42a8acdd5ed63827c158f7763">NonCopyable</a> (const <a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a> &amp;)=delete</td></tr>
<tr class="separator:aded750a42a8acdd5ed63827c158f7763 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537645a43274a8d742eed00a35ffb917 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a537645a43274a8d742eed00a35ffb917">NonCopyable</a> (<a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a537645a43274a8d742eed00a35ffb917 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef35c286da3c2b8c90da9bb50aaddf1 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#adef35c286da3c2b8c90da9bb50aaddf1">operator=</a> (const <a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a> &amp;)=delete</td></tr>
<tr class="separator:adef35c286da3c2b8c90da9bb50aaddf1 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9888c9e5345760386ac57ff6439a30e4 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a9888c9e5345760386ac57ff6439a30e4">operator=</a> (<a class="el" href="classxmlpp_1_1NonCopyable.html">NonCopyable</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a9888c9e5345760386ac57ff6439a30e4 inherit pub_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classxmlpp_1_1Node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classxmlpp_1_1Node')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a></td></tr>
<tr class="memitem:a616a872d0fbd86206c0beee0be5abee3 inherit pub_static_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#a616a872d0fbd86206c0beee0be5abee3">create_wrapper</a> (_xmlNode * node)</td></tr>
<tr class="memdesc:a616a872d0fbd86206c0beee0be5abee3 inherit pub_static_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the correct C++ instance for a given libxml C struct instance.  <a href="classxmlpp_1_1Node.html#a616a872d0fbd86206c0beee0be5abee3">More...</a><br /></td></tr>
<tr class="separator:a616a872d0fbd86206c0beee0be5abee3 inherit pub_static_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47901df78305a685fc9682cd44290d6 inherit pub_static_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#aa47901df78305a685fc9682cd44290d6">free_wrappers</a> (_xmlNode * node)</td></tr>
<tr class="memdesc:aa47901df78305a685fc9682cd44290d6 inherit pub_static_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the C++ instance for a given libxml C struct instance, and also recursively destroy the C++ instances for any children.  <a href="classxmlpp_1_1Node.html#aa47901df78305a685fc9682cd44290d6">More...</a><br /></td></tr>
<tr class="separator:aa47901df78305a685fc9682cd44290d6 inherit pub_static_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3af70bdc909d8d272b3df0634fb291b inherit pub_static_methods_classxmlpp_1_1Node"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1Node.html#af3af70bdc909d8d272b3df0634fb291b">remove_node</a> (<a class="el" href="classxmlpp_1_1Node.html">Node</a> * node)</td></tr>
<tr class="memdesc:af3af70bdc909d8d272b3df0634fb291b inherit pub_static_methods_classxmlpp_1_1Node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node and its children.  <a href="classxmlpp_1_1Node.html#af3af70bdc909d8d272b3df0634fb291b">More...</a><br /></td></tr>
<tr class="separator:af3af70bdc909d8d272b3df0634fb291b inherit pub_static_methods_classxmlpp_1_1Node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classxmlpp_1_1NonCopyable"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classxmlpp_1_1NonCopyable')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classxmlpp_1_1NonCopyable.html">xmlpp::NonCopyable</a></td></tr>
<tr class="memitem:a96e2e5582c5bb88b2dea2adb9f9512e2 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a96e2e5582c5bb88b2dea2adb9f9512e2">NonCopyable</a> () noexcept</td></tr>
<tr class="separator:a96e2e5582c5bb88b2dea2adb9f9512e2 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e2e0391beb4b8f20f5d51e8a253d63 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxmlpp_1_1NonCopyable.html#a14e2e0391beb4b8f20f5d51e8a253d63">~NonCopyable</a> ()</td></tr>
<tr class="separator:a14e2e0391beb4b8f20f5d51e8a253d63 inherit pro_methods_classxmlpp_1_1NonCopyable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Element nodes have attributes as well as child nodes. </p>
<p>This will be instantiated by the parser. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a74581b2c25aaa277cf0153af74fcbc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74581b2c25aaa277cf0153af74fcbc31">&#9670;&#160;</a></span>AttributeList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Element.html#a74581b2c25aaa277cf0153af74fcbc31">xmlpp::Element::AttributeList</a> =  <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08383.html">std::list</a>&lt;<a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb2a056f183f2c3ddeb1ddf5a9316006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2a056f183f2c3ddeb1ddf5a9316006">&#9670;&#160;</a></span>const_AttributeList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classxmlpp_1_1Element.html#afb2a056f183f2c3ddeb1ddf5a9316006">xmlpp::Element::const_AttributeList</a> =  <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a08383.html">std::list</a>&lt;const <a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>*&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="addce07f26b8ca52beb583d942375a756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addce07f26b8ca52beb583d942375a756">&#9670;&#160;</a></span>Element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xmlpp::Element::Element </td>
          <td>(</td>
          <td class="paramtype">_xmlNode *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cdba1990c4620a4b02b4fcd4a4afa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdba1990c4620a4b02b4fcd4a4afa2d">&#9670;&#160;</a></span>~Element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xmlpp::Element::~Element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a45b7f4040d66fc847a1040ae961b923d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b7f4040d66fc847a1040ae961b923d">&#9670;&#160;</a></span>add_child_cdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1CdataNode.html">CdataNode</a>* xmlpp::Element::add_child_cdata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a new CDATA node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>The raw text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new CDATA node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee69d63061e05c765d32a686a4434d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee69d63061e05c765d32a686a4434d9d">&#9670;&#160;</a></span>add_child_comment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1CommentNode.html">CommentNode</a>* xmlpp::Element::add_child_comment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a new comment node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>The text. This should be unescaped - see <a class="el" href="classxmlpp_1_1ContentNode.html#aa131bfc63bd9f482fcf07748991fe449" title="Set the text of this content node.">ContentNode::set_content()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new comment node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec3e495a0766d81b5a83e7a3146da683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3e495a0766d81b5a83e7a3146da683">&#9670;&#160;</a></span>add_child_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Element::add_child_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a child element to this node. </p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000011">Since libxml++ 3.0:</a></b></dt><dd>Replaces Node::add_child()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The new node name </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The namespace prefix. If the prefix has not been declared then this method will throw an exception. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly-created element </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If a namespace prefix is specified, but has not been declared. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If this node is not an element node, or the child node cannot be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada475bd91e7deb727aba6fa99f9d1a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada475bd91e7deb727aba6fa99f9d1a1b">&#9670;&#160;</a></span>add_child_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Element::add_child_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a> *&#160;</td>
          <td class="paramname"><em>previous_sibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a child element to this node after the specified existing child node. </p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000012">Since libxml++ 3.0:</a></b></dt><dd>Replaces Node::add_child()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous_sibling</td><td>An existing child node. </td></tr>
    <tr><td class="paramname">name</td><td>The new node name </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The namespace prefix. If the prefix has not been declared then this method will throw an exception. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly-created element </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If a namespace prefix is specified, but has not been declared. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If this node is not an element node, or the child node cannot be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5ecc3e0312fc29a49aa9b471a947a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ecc3e0312fc29a49aa9b471a947a19">&#9670;&#160;</a></span>add_child_element_before()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Element::add_child_element_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a> *&#160;</td>
          <td class="paramname"><em>next_sibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a child element to this node before the specified existing child node. </p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000013">Since libxml++ 3.0:</a></b></dt><dd>Replaces Node::add_child_before()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_sibling</td><td>An existing child node. </td></tr>
    <tr><td class="paramname">name</td><td>The new node name </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The namespace prefix. If the prefix has not been declared then this method will throw an exception. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly-created element </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If a namespace prefix is specified, but has not been declared. </td></tr>
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If this node is not an element node, or the child node cannot be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a853ac21a9510bbdef9d829dfb6d14dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853ac21a9510bbdef9d829dfb6d14dfd">&#9670;&#160;</a></span>add_child_element_before_with_new_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Element::add_child_element_before_with_new_ns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a> *&#160;</td>
          <td class="paramname"><em>next_sibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a child element to this node before the specified existing child node. </p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000016">Since libxml++ 3.0:</a></b></dt><dd>Replaces Node::add_child_before_with_new_ns()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_sibling</td><td>An existing child node. </td></tr>
    <tr><td class="paramname">name</td><td>The new node name. </td></tr>
    <tr><td class="paramname">ns_uri</td><td>The namespace to associate with the prefix, or to use as the default namespace if no prefix is specified. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The prefix of the node's namespace. If no prefix is specified then the namespace URI will be the default namespace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly-created element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If this node is not an element node, or the child node or the namespace node cannot be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04d344410c6deb3eee2a1bb9bc478375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d344410c6deb3eee2a1bb9bc478375">&#9670;&#160;</a></span>add_child_element_with_new_ns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Element::add_child_element_with_new_ns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a child element to this node. </p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000014">Since libxml++ 3.0:</a></b></dt><dd>Replaces Node::add_child_with_new_ns()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The new node name. </td></tr>
    <tr><td class="paramname">ns_uri</td><td>The namespace to associate with the prefix, or to use as the default namespace if no prefix is specified. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The prefix of the node's namespace. If no prefix is specified then the namespace URI will be the default namespace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly-created element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If this node is not an element node, or the child node or the namespace node cannot be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad850fef0eb9000bc858e5b2dc0e55092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad850fef0eb9000bc858e5b2dc0e55092">&#9670;&#160;</a></span>add_child_element_with_new_ns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html">Element</a>* xmlpp::Element::add_child_element_with_new_ns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a> *&#160;</td>
          <td class="paramname"><em>previous_sibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a child element to this node after the specified existing child node. </p>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000015">Since libxml++ 3.0:</a></b></dt><dd>Replaces Node::add_child_with_new_ns()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous_sibling</td><td>An existing child node. </td></tr>
    <tr><td class="paramname">name</td><td>The new node name. </td></tr>
    <tr><td class="paramname">ns_uri</td><td>The namespace to associate with the prefix, or to use as the default namespace if no prefix is specified. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The prefix of the node's namespace. If no prefix is specified then the namespace URI will be the default namespace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly-created element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td>If this node is not an element node, or the child node or the namespace node cannot be created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a775c3a4b5da4d168376b0a61a1ad2040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775c3a4b5da4d168376b0a61a1ad2040">&#9670;&#160;</a></span>add_child_entity_reference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1EntityReference.html">EntityReference</a>* xmlpp::Element::add_child_entity_reference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a new entity reference node. </p>
<p>The reference can be either an entity reference ("name" or "&amp;name;") or a character reference ("#dec", "#xhex", "&amp;#dec;", or "&amp;#xhex;").</p>
<p>'&amp;' and ';' are optional. If they exist, they are stripped from the stored copy of the name. <a class="el" href="classxmlpp_1_1Node.html#a241a2a8259f4d1f88a1ff350e4ec31a3" title="Get the name of this node.">Node::get_name()</a> returns the name without '&amp;' and ';'. If the <a class="el" href="classxmlpp_1_1Document.html" title="Represents an XML document in the DOM model.">Document</a> is written to an XML file, '&amp;' and ';' are written.</p>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000007">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the entity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new entity reference node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a180c2e543c9ad54d352f364ad8241622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180c2e543c9ad54d352f364ad8241622">&#9670;&#160;</a></span>add_child_processing_instruction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1ProcessingInstructionNode.html">ProcessingInstructionNode</a>* xmlpp::Element::add_child_processing_instruction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a new processing instruction node. </p>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000008">Since libxml++ 2.36:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the application to which the instruction is directed. </td></tr>
    <tr><td class="paramname">content</td><td>The content of the instruction. This should be unescaped - see <a class="el" href="classxmlpp_1_1ContentNode.html#aa131bfc63bd9f482fcf07748991fe449" title="Set the text of this content node.">ContentNode::set_content()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new processing instruction node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29128571895c5f7b77382ed69c18726c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29128571895c5f7b77382ed69c18726c">&#9670;&#160;</a></span>add_child_text() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* xmlpp::Element::add_child_text </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>content</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append a new text node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>The text. This should be unescaped - see <a class="el" href="classxmlpp_1_1ContentNode.html#aa131bfc63bd9f482fcf07748991fe449" title="Set the text of this content node.">ContentNode::set_content()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new text node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe27ad61606dac9da274c8b43c5708aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe27ad61606dac9da274c8b43c5708aa">&#9670;&#160;</a></span>add_child_text() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* xmlpp::Element::add_child_text </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a> *&#160;</td>
          <td class="paramname"><em>previous_sibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>content</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new text node after the specified existing child node. </p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000001">Since libxml++ 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">previous_sibling</td><td>An existing child node. </td></tr>
    <tr><td class="paramname">content</td><td>The text. This should be unescaped - see <a class="el" href="classxmlpp_1_1ContentNode.html#aa131bfc63bd9f482fcf07748991fe449" title="Set the text of this content node.">ContentNode::set_content()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new text node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67870433ece791c1204aef49d4348319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67870433ece791c1204aef49d4348319">&#9670;&#160;</a></span>add_child_text_before()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* xmlpp::Element::add_child_text_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classxmlpp_1_1Node.html">xmlpp::Node</a> *&#160;</td>
          <td class="paramname"><em>next_sibling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>content</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new text node before the specified existing child node. </p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000002">Since libxml++ 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">next_sibling</td><td>An existing child node. </td></tr>
    <tr><td class="paramname">content</td><td>The text. This should be unescaped - see <a class="el" href="classxmlpp_1_1ContentNode.html#aa131bfc63bd9f482fcf07748991fe449" title="Set the text of this content node.">ContentNode::set_content()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new text node. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5786c9bbdcb50b0defe8cfb4e51c1fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5786c9bbdcb50b0defe8cfb4e51c1fca">&#9670;&#160;</a></span>get_attribute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>* xmlpp::Element::get_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the attribute with this name, and optionally with this namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the attribute that will be retrieved. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>Namespace prefix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute, or <code>nullptr</code> if no suitable <a class="el" href="classxmlpp_1_1Attribute.html" title="Represents an XML attribute node or attribute declaration.">Attribute</a> was found. Is either an AttributeNode*, pointing to an explicitly set attribute, or an AttributeDeclaration*, pointing to the declaration of an attribute with a default value. </dd></dl>

</div>
</div>
<a id="a4cd49ca593243f4d30b9fae7cc14175b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd49ca593243f4d30b9fae7cc14175b">&#9670;&#160;</a></span>get_attribute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>* xmlpp::Element::get_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the attribute with this name, and optionally with this namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the attribute that will be retrieved. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>Namespace prefix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute, or <code>nullptr</code> if no suitable <a class="el" href="classxmlpp_1_1Attribute.html" title="Represents an XML attribute node or attribute declaration.">Attribute</a> was found. Is either an AttributeNode*, pointing to an explicitly set attribute, or an AttributeDeclaration*, pointing to the declaration of an attribute with a default value. </dd></dl>

</div>
</div>
<a id="a4d704c3d807bc55f47945e3da7ee1428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d704c3d807bc55f47945e3da7ee1428">&#9670;&#160;</a></span>get_attribute_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> xmlpp::Element::get_attribute_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the value of the attribute with this name, and optionally with this namespace. </p>
<p>For finer control, you might use <a class="el" href="classxmlpp_1_1Element.html#a5786c9bbdcb50b0defe8cfb4e51c1fca" title="Get the attribute with this name, and optionally with this namespace.">get_attribute()</a> and use the methods of the <a class="el" href="classxmlpp_1_1Attribute.html" title="Represents an XML attribute node or attribute declaration.">Attribute</a> class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the attribute whose value will be retrieved. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>Namespace prefix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The text value of the attribute, or an empty string if no such attribute was found.</dd></dl>
<dl class="since_2_20"><dt><b><a class="el" href="since_2_20.html#_since_2_20000001">Since libxml++ 2.20:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a8fbb85e7ecabc5a8b9b39638f94e4fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbb85e7ecabc5a8b9b39638f94e4fb7">&#9670;&#160;</a></span>get_attributes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html#a74581b2c25aaa277cf0153af74fcbc31">AttributeList</a> xmlpp::Element::get_attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the list of explicitly set attributes for this element. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of explicitly set attributes. </dd></dl>

</div>
</div>
<a id="a215ca85858f1c51648a153a9c03154d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215ca85858f1c51648a153a9c03154d7">&#9670;&#160;</a></span>get_attributes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Element.html#afb2a056f183f2c3ddeb1ddf5a9316006">const_AttributeList</a> xmlpp::Element::get_attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the list of explicitly set attributes for this element. </p>
<dl class="section return"><dt>Returns</dt><dd>The list of explicitly set attributes. </dd></dl>

</div>
</div>
<a id="ab69d8c22b51bcfddebc1b52d0739db8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab69d8c22b51bcfddebc1b52d0739db8c">&#9670;&#160;</a></span>get_first_child_text() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* xmlpp::Element::get_first_child_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first child text content node. </p>
<p>This is a convenience method, meant as an alternative to iterating over all the child nodes to find the first suitable node and then getting the text directly. </p><dl class="section return"><dt>Returns</dt><dd>The first text node, if any.</dd></dl>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000017">Since libxml++ 3.0:</a></b></dt><dd>Replaces get_child_text(). </dd></dl>

</div>
</div>
<a id="a3dbda06fa105905e7e138585946ddd6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dbda06fa105905e7e138585946ddd6e">&#9670;&#160;</a></span>get_first_child_text() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classxmlpp_1_1TextNode.html">TextNode</a>* xmlpp::Element::get_first_child_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first child text content node. </p>
<p>This is a convenience method, meant as an alternative to iterating over all the child nodes to find the first suitable node and then getting the text directly. </p><dl class="section return"><dt>Returns</dt><dd>The first text node, if any.</dd></dl>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000018">Since libxml++ 3.0:</a></b></dt><dd>Replaces get_child_text(). </dd></dl>

</div>
</div>
<a id="aaf163cefbd08210bdb3c00598ef4164f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf163cefbd08210bdb3c00598ef4164f">&#9670;&#160;</a></span>has_child_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xmlpp::Element::has_child_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discover whether one of the child nodes is a text node. </p>
<p>This is a convenience method, meant as an alternative to iterating over all the child nodes and examining them directly. </p><dl class="section return"><dt>Returns</dt><dd>Whether this node has a child text node. </dd></dl>

</div>
</div>
<a id="a9959d2eba5aaaf5f98086a6f560a7469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9959d2eba5aaaf5f98086a6f560a7469">&#9670;&#160;</a></span>remove_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xmlpp::Element::remove_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the attribute with this name, and optionally with this namespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the attribute to be removed </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>Namespace prefix. If specified, the attribute will be removed only if the attribute has this namespace. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9b29402f1d61113d8a8929f28d106d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b29402f1d61113d8a8929f28d106d8">&#9670;&#160;</a></span>set_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxmlpp_1_1Attribute.html">Attribute</a>* xmlpp::Element::set_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of the attribute with this name, and optionally with this namespace. </p>
<p>A matching attribute will be added if no matching attribute already exists. For finer control, you might want to use <a class="el" href="classxmlpp_1_1Element.html#a5786c9bbdcb50b0defe8cfb4e51c1fca" title="Get the attribute with this name, and optionally with this namespace.">get_attribute()</a> and use the methods of the <a class="el" href="classxmlpp_1_1Attribute.html" title="Represents an XML attribute node or attribute declaration.">Attribute</a> class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the attribute whose value will change. </td></tr>
    <tr><td class="paramname">value</td><td>The new value for the attribute </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>Namespace prefix. If the prefix has not been declared then this method will throw an exception. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute that was changed, or <code>nullptr</code> is no suitable <a class="el" href="classxmlpp_1_1Attribute.html" title="Represents an XML attribute node or attribute declaration.">Attribute</a> was found. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16b60b87a98064e053c75098c74887e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b60b87a98064e053c75098c74887e7">&#9670;&#160;</a></span>set_first_child_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xmlpp::Element::set_first_child_text </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>content</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the text of the first text node, adding one if necessary. </p>
<p>This is a convenience method, meant as an alternative to iterating over all the child nodes to find the first suitable node and then setting the text directly. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>The text. This should be unescaped - see <a class="el" href="classxmlpp_1_1ContentNode.html#aa131bfc63bd9f482fcf07748991fe449" title="Set the text of this content node.">ContentNode::set_content()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1internal__error.html">xmlpp::internal_error</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="since_3_0"><dt><b><a class="el" href="since_3_0.html#_since_3_0000019">Since libxml++ 3.0:</a></b></dt><dd>Replaces set_child_text(). </dd></dl>

</div>
</div>
<a id="a4ff97d55a647c9d3ac8ea77b978124d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff97d55a647c9d3ac8ea77b978124d1">&#9670;&#160;</a></span>set_namespace_declaration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xmlpp::Element::set_namespace_declaration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a> &amp;&#160;</td>
          <td class="paramname"><em>ns_prefix</em> = <code><a class="el" href="namespacexmlpp.html#a8cc9953d3fefa9134f2ba9a3b2ca1abe">ustring</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a namespace declaration to this node which will apply to this node and all children. </p>
<p>If the added namespace prefix is equal to the prefix associated to the node, the associated namespace of the node itself is updated, but child nodes are not updated. If you use this method on a node after children have been added, it may be necessary to save the XML document and reparse it to get correct namespaces on all nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns_uri</td><td>The namespace to associate with the prefix, or to use as the default namespace if no prefix is specified. </td></tr>
    <tr><td class="paramname">ns_prefix</td><td>The namespace prefix. If no prefix is specified then the namespace URI will be the default namespace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxmlpp_1_1exception.html" title="Base class for all xmlpp exceptions.">xmlpp::exception</a></td><td>If a new namespace node cannot be created, e.g. because a namespace with the same prefix but another URI already exists. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Mar 22 2023 13:16:31 for libxml++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
